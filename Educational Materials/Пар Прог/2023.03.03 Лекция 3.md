Последняя лекция по Open MP
Повторение. Есть два типа памяти: private и shared. Распараллеливание цикла for работает по-разному с помощью scheduler'a.
# Распараллеливание с редукцией
Не будет рассмотрены Task в OpenMP, а в TBB. Будем смотреть редукцию. 
Параметр reduction опр-ет список перем-ых, для кот вып-ся операция редукции.
#pragma omp parallel for schedule (static, chunk)\
reduction(+: result)
for(int i=0;i<n;i++){
	result = result +(a[i]\*b[i]);
}
Обычно делают по одной перем-ной. Она должна быть объявлена до секции => shared перем-ная, внешняя для секции. Каждый поток будет работать со своей копией result. Когда зак-ся вып-е цикла, reduction будет вып-но над всеми частными перем-ными result. В result будет положен результат редукции.
Не все операции допустимы. Это + - \* & ^ | && ||
Допустимы операции типа += и инкременты/декременты (постфиксные, префиксные). 
Получаем решение "в одну строчку". Сделали pragma parallel, omp for и reduction. 
## Директива simd
Просьба векторизовать нижеследующие циклы.
#pragma omp simd [clause ...]
	for_loops
Векторизация: если в прошлом примере её исп-ть, то когда поток получит свою часть, то
Когда нужно вып-ть a[i]\*b[i], то будут загружены ещё неск эл-тов  (число зав-т от линейки кэша и р-ра данных). Например, 16 операций будет вып-но без обращения к оперативке. Кроме того, сущ-ют векторные операции у CPU над набором данных, т.е. за одну команду сразу несколько операций. Несколько операций за то же время, что и одна невекторная операция. Если их можно исп-ть, то можно получить ускорение "на ровном месте".
## Директива threadprivate
Размещение данных локальное, но в параллельной секции есть свой у каждого потока, причём между секциями сохр-ся сост-е массива.
![[Pasted image 20230303164548.png]]
copyin - пар-тр чаще всего для threadprivate. Позволяет сост-е master-потока раскопировать всем остальным.
# Синхронизация
## Директива master
Опр-ет фрагмент кода, кот должен быть вып-н только осн потоком. Все остальные потоки пропускают данный фрагмент кода. Заверш-е директивы не синх-ся.
#pragma omp master newline
	structured_block
## Директива barrier
#pragma omp barrier newline
Опр-ет точку синх-ии, кот должны достигнуть все потоки для продолж-я выч-ий (директива должна быть вложена в блок).
## Директива single
Если должен быть вып-н одним любым потоком, то
#pragma omp single [clause ...]
	structured_block
Пар-тры:
1. private(list)
2. firstprivate(list)
3. copyprivate(list)
4. nowait
Это нек точка синх-ии
## Директива critical
Опр-ет фрагмент кода, кот должен вып-ся только одним потоком в один момент времени (критическая секция)
#pragma omp critical [name] newline
	structured_block
Тот, который первый добрался, блокирует блок и вып-ся. Все остальные ждут. Потом следующий и т.д.
## Директива atomic
Опр-ет перем-ю, операция с кот должна быть вып-на как неделимая.
Требования:
1. Скалярная переменная
2. Нет рекурсий
3. Операция не должна быть перегружена
Тогда можно заменить critical на atomic, что может дать прирост скорости. Нельзя прерывать поток для вып-я => не будет неправ рез-та
## Замки
omp_lock_t - тип данных "замок"
void omp_init_lock(omp_lock_t \* lock) - инициализировать замок
void omp_destroy_lock(omp_lock_t \* lock) - удалить замок
omp_set_lock(omp_lock_t \* lock) - захватить, если свободен, иначе ждать освобождения.
omp_unset_lock(omp_lock_t \* lock) - освободить замок
int omp_test_lock(omp_lock_t \* lock) - попробовать захватить замок. Если не вышло, даёт 0. Если вышло, то захватывает и даёт истину. Даёт возм-ть делать что-то другое, если замок занят.
# Переменные окр-я
![[Pasted image 20230303170751.png]]
За кадром остался мех-м omp section - распараллеливание раздельных фрагментов кода (функциональное распараллеливание). Более для программ классических многопоточных (а не параллельных). Внтури этого блока кода нужно исп-ть явное кол-во директив omp_section. Какое число ук-но, такое и будет. Каждая отдельная секция будет выдана отдельному потоку. Неизвестно, которому. Нет гарантий одновременной работы