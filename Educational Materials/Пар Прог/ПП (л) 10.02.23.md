![[Pasted image 20230210162340.png]]TBB написана только для C++, OpenMP для C, Fortran. 
Общая память - все компьютеры, ноутбуки, смартфоны (несколько ядер и одна доступная память).
Производительность дают только эти три языка. OpenMP - наиболее часто применяемая библиотека.
Самое эффективное - MPI+многопоточность+счёт на графике или сопроцессорах. Но это очень сложно, поэтому зачастую стараются совмещать.
Будут три лекции по OpenMP.
![[Pasted image 20230210163232.png]] openmp.org - основной сайт по OpenMP. В 2021 была выпущена спецификация 5.2. Стандарт очень хорошо написан, поэтому его можно читать. Примеры находятся по отдельным ссылкам.
![[Pasted image 20230210163830.png]]
Механизм задач - параллельность рекурсии.
Два варианта: 
1. Данные в общей памяти, они только читаются.
2. Синхронизация (если данные меняются)
Переменные окружения - возможность настройки OpenMP-программ
## Основы
![[Pasted image 20230210164336.png]]
![[Pasted image 20230210164406.png]]
Последовательная версия на C++: ![[Pasted image 20230210164515.png]]
![[Pasted image 20230210164818.png]] HANDLE - массив дескрипторов.
![[Pasted image 20230210165202.png]] если заменить &threadArg[i] на &i, то можем получить, что поток снят с исполнения, и это нарушит всё (потоки обращаются в таком случае к одной памяти).
![[Pasted image 20230210170356.png]]
## Структура OpenMP
![[Pasted image 20230210170723.png]] Библиотека функций относительно небольшая.
![[Pasted image 20230210171001.png]] При переходе в последовательную часть возможен сценарий, что ненужные уже потоки переводятся в режим ожидания. 
Главный поток обычно сам также занимается вычислениями.
План разработки эффективных вещей:
- сделали последовательную версию
- проверили скорость. Если медленно:
- нашли наиболее долгий участок кода и распараллелили его
- И так далее, если слишком долго выполняется.
Рассматривается модель памяти до OpenMP 4.0
![[Pasted image 20230210171807.png]]
![[Pasted image 20230210171850.png]] stuctured_block - либо одна строка, либо блок в фигурных скобках.
Параметры могут иметь вложенность. Вложенности глубины больше двух не бывает.
Условие бывает если при разработке библиотечной функции может быть так, что данных мало, отчего параллельность только ухудшит.
Ограничения для числа потоков: 
- число ядер
- количество памяти под сегменты стека и т.д. (4500 потоков потребуют минимум 4500 байт под сегмент стека, чего не может быть в x86).
Решение при большом числе потоков:
- оставить только один поток
- оставить некоторое возможное число потоков
- снять программу с исполнения
![[Pasted image 20230210172923.png]]
Пример:
![[Pasted image 20230210173142.png]]
Переменная tid - частная (private), а nthreads - общая (shared), хотя обе локальные.
## Установка количества потоков
![[Pasted image 20230210174009.png]] Старшинство: если не написано одно, то можно через другое. Например, если нет параметра директивы, то можно запустить функцию установки числа потоков.
## Определение времени выполнения параллельной программы
![[Pasted image 20230210174608.png]] 
Точность через omp_get_wtick()
__Будет тестирование по OpenMP+TBB__