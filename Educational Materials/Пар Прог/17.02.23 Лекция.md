### Пример
![[Pasted image 20230217162539.png]]
Можно вставлять в число потоков переменную. 
Тут создаются 2000 потоков - 2000 МБ нужно будет - в Win32 не запустятся все. В MSVS 2022 будет создан только один поток. В другом компиляторе может просто сняться с исполнения с сообщением. Ранее в VS ограничивалось 64 потоками. Программа на OpenMP компилируется в код, который использует многопоточность ОС. В Win это WaitForMultipleObjects. В ней среди всех наборов дескрипторов обеспечивается ожидание первых 64 объектов. Поэтому это встречалось в ранних Visual Studio.
Сейчас число потоков измеряется десятками, а не сотнями (если не учитывать графические процессоры), поэтому 64 - нормальное число.
При добавлении другой секции под первой можно задать другое количество потоков. В VS можно задавать также ключ компилятора для запуска из командной строки. Для ручного запуска нужно включить OpenMP:
![[Pasted image 20230217163651.png]]
## Управление областью видимости
Директивы, управляющие областью видимости:
- shared, default
- private
- firstprivate
- lastprivate

- Глобальная переменная. Доступна во всём файле, если не перекрыта локальной. К ней имеют доступ все потоки, если не замещена.
- Локальная переменная.
	- Если объявлена не в parallel, то находится в shared - есть в одном экземпляре (возможна гонка данных). Каким-то образом обеспечивается, что переменная, локальная для данной функции, видна потоковым функциям.
	- Объявлена в секции parallel - своя для каждого потока.
	- private(название переменных через запятую). Каждая из них будет локализована. Каждый поток будет работать со своей локальной копией.![[Pasted image 20230217164343.png]] Скорее всего, создаётся в потоковой функции локальная переменная.
Поведение по умолчанию (default) - shared. Иначе можно установить none => все переменные должны быть явно перенесены либо в shared, либо в private (отключение неявного перевода в shared). Позволяет явно видеть все переменные в этих списках. ![[Pasted image 20230217164745.png]]
### Замечание по private: 
Если и было значение, но было перекрыто новой переменной в private, то значение не останется. Чтобы оно было передано, нужно использовать firstprivate. У каждого потока будет своя такая переменная, и её начальным значением будет последнее значение ранее объявленной.![[Pasted image 20230217165013.png]]
Особенность: у нулевого потока будет две таких переменных, но внутри блока будет видна только  firstprivate (из-за замещения).
### lastprivate
Копирует из какой-то частной переменной потока (последнего выполнившегося) сост-е в исх перем-ную, от которой мы копировались. Начальное состояние не копируется. Препод не пробовал совместить firstprivate и lastprivate (*можно попробовать*).
*В Visual Studio часто нет последних особенностей OpenMP, например, вложенной параллельности*.
## Библиотека функций
![[Pasted image 20230217165550.png]]
Некоторые компиляторы требуют всегда включения omp.h, если ключ подключён. 
Вторая ф-ия может быть вызвана и в парал, и в послед обл-тях.
![[Pasted image 20230217165740.png]]
omp_get_num_procs учитывает ограничения. Если они не выставлены, то вернётся число вирт. потоков.
Зачем нужна третья ф-ия: 
- Бывает, что мы вызываем ф-ию, окружая её парал обл-ю, а потом вызывам вне парал обл-ти. Поэтому внутри ф-ии можно вызывать omp_in_parallel. Если 0, то вне парал обл-ти.
### Вложенный параллелизм
![[Pasted image 20230217170044.png]]
По умолчанию вложенный параллелизм отключён, даже если компилятор поддерживает его. Если не поддерживает, то включение ничего не даёт.
Применение вложенной параллельности: в параллельном блоке создали другой паралельный блок. Если во внешней парал секции 2 потока, а во внутр 3 потока, то с включённым вложенным параллелизмом будет
![[Pasted image 20230217170355.png]]
Строки 15-16 будут выполнять две команды по три потока. При вызове omp_get_thread_num получим два раза 0, 1, 2. Для уникальности нужно как-то запоминать номера потоков.
Можно считать, что строится некоторое дерево: был один поток, он раздвоился, а потом каждый из них растроился.
## Привязка потоков
По умолчанию ОС перебрасывает потоки относительно ядер как угодно. В этом случае закачанный кэш в одно ядро пропадёт: нужно будет закачивать в другое, если поток прервался, а потом запустился на другом ядре. Это выгодно с точки зрения ОС, но плохо для HPC. 
В стандарте 4.0 добавлен пар-р proc_bind, опр-щий способы "привязки" потоков к исполнительным уст-вам.
![[Pasted image 20230217170909.png]]
- master. Назначить все потоки в команде на то же уст-во, на кот исполняется master-поток. Очень неэффективно.
- close. Распределить потоки по уст-вам в порядке "деление по модулю". Пусть 4 ядра и 8 потоков. 8 / 4 = 2. Нулевой поток попал на первое ядро, второй - 2-е, третий - 3-е, ... 5-й - на 1-е ядро.
- spread. Распределение по блокам. 8 / 4 = 2. Первый и второй на первом ядре, второй и третий - на втором.
## Способы распределения работы между потоками
Есть автоматическое распределение. 
Директивы распр-я выч-ий в парал обл-ти:
- for - распараллеливание циклов
- sections - распараллеливание раздельных фрагментов кода (функц распараллеливание)
- single - директива для указания последовательного вып-я кода.
Начало вып-я директив по умолч-ю не синх-ся (как только первый готов, он сразу приступает). Завершение директив по умолч-ю синхронное.
Получаем, что начинает самый первый, а потом все остальные ждут последнего.
### for
![[Pasted image 20230217171651.png]]
nowait - отменяет ожидание в конце цикла
schedule - сформировать расписание (схему распределения). 
Пример: 
![[Pasted image 20230217171824.png]]
i - private, чтобы потоки друг другу не мешали. Можно также объявить внутри парал секции. Если omp for будет исполняться вне parallel обл-ти, то параллельности не будет.
Требования:
- цикл for может следовать за pragma for сразу на следующей строке (нельзя пустую строку вставлять, можно комментарий)
- цикл for должен быть написан в канонич. форме, чтобы было точно известно, сколько итераций будет выполняться. Приращения могут быть любыми (+=2, +=var). Если внутри цикла будем менять i или n (для кот i всегда меньше), то компилятор не будет распараллеливать. 
scedule: три варианта.
![[Pasted image 20230217172431.png]]
Доп-но: ![[Pasted image 20230217173343.png]]
Обработка static: 
- 1000, 4 потока: по 250 итераций. Нулевой: 0-249 итерации, и т.д.
- 1000, 3 потока: по 333 итерации каждому, одному доп-ная.
- Часто используют блоки: schedule(static, chunk), где chunk - переменная, опр-щая размер блока вплоть до n (тогда вып-ть будет 1, чтобы не нужно было тратиться на создание и синхронизацию). chunk = 1 => каждому потоку по одной итерации и большому числу блоков. Часто блоков больше, чем потоков. Если chunk = 100, а потоков 4, то 0-й будет вып-ть 0-й блок, 4-й блок, 8-й блок. Два последних потока получат по два блока. Стоит делать довольно большие чанки (кроме операций, где очень объёмные вычисления), чтобы использовать кэширование.
- Проблема: мы хотим разложить на простые сомножители числа от 1 до 1000 000. В среднем чем больше число, тем больше делителей, но не всегда. Нельзя придумать статич. расписание.
Обработка dynamic:
![[Pasted image 20230217173400.png]]
- будет 10 блоков (блок по 100). Будет организована на логическом уровне очередь. Это сложнее, поэтому этот вариант дольше, чем static => лучше начать со static. 
- Первый готовый поток обращается к очереди и берёт первый незанятый блок. Следующий готовый забирает второй блок. Когда-то все становятся заняты. 
- Освободившийся поток берёт новый блок кода.
- Это позволяет сбалансировать вып-е.
- dynamic используется во многом при очень сложных выч-но итерациях или очень разных по выч сложности, как в примере с разложением на множители.
- Если каждый следующий блок итераций тяжелее, чем предыдущий, то подойдёт guided.
guided:
- chunk работает как размер блока в виде нек порога. Было 800 итераций и 4 потока. Первый готовый опр-ет общее число итераций и потоков. 800 / 4 = 200, chunk =100, берёт себе 200
- Другой берёт 600, делит на 4, 150 > 100, берёт 150
- Третий берёт себе где-то 133
- Размер блока будет уменьшаться, пока не будет равен или меньше чанка. Как только будет меньше или равен, то деления прекращаются и блоки становятся такого размера.
- Применяется редко на практике. Для простых сомножителей подойдёт.
### Объединение parallel и for
![[Pasted image 20230217174313.png]]
Если есть только цикл for. Пишем его всё равно в канонич форме.
