Сегодня будет лекция, потом будет выложено расписание для групп + практическое задание.
В сетевых приложениях взаимодействуют обычно несколько пользователей => для интерактивности нужно использовать многопоточность.
В качестве примера даётся приложение с шариком, который можно заставить двигаться. Два потока: поток для отображения  и поток, вычисляющий движение. Основные вещи будут показаны в NoBind со свингом, потом в Idea с Java FX.
При наследовании MainFrame можно запустить - появится стандартное приложение.
## Отображение шарика (в виде окружности)
Нужно разработать собственный компонент. 
![[Pasted image 20230218110233.png]]
Можно наследовать от JPanel - делаем MyPanel. Внутри наследника можно устанавливать настройки: фон, граница, ...
Чтобы отобразить шарик, нужно его нарисовать. Рисование на существующем фрейме нужно перегрузить метод paintComponent() или pain()
Правило перегрузки:
**Пропущено**
Добавим дополнительные возможности.
## Перемещение по клику мышки
1. Ввести координаты шарика x и y.
2. По этим координатам рисовать
3. Метод drawOwal(x-r,y-r,2 \* r,2 \* r)
4. ![[Pasted image 20230218111257.png]] Перегрузить событие, связанное с кликом. Появляются слушатели (addMouseListener) и перегрузка одного из методов у слушателя.
5. Сделать отдельный метод перемещения шарика public void moveCircle(int x, int y)
6. void moveCircle(int x, int y){
	this.x = x;
	this.y=y;
	this.repaint();
	}
7. formMouseClicked(...){
	moveCircle(evt.getX(), evtgetY());
	}
## Перемещение шарика в отдельном потоке
1. Создадим метод public void next(){
		int newx= x+5;
		if(newx > this.getWidth())
			newx=0;
		moveCircle(newx, y);
		}
2. Создать кнопку с именем
3. Создать обработчик, кот вызывает метод next()
4. Создадим отдельный поток, работающий отедельно. Создадим кнопку Start
5. Мы должны сохранить ссылку на поток, чтобы иметь возм-ть управлять (старт, остановка, возобновление )
6. Создадим потоковую переменную
	1. породить наследника
	2. перегрузка интерфейса runnable
	3. лямбда-выражение
7. t = new Thread( ()->
	{ while(true){
		myPanel1.next();
		try{
		Thread.sleep(100);
		}catch(InterruptedException ex){
		}
		});
		t.start();
	}
8. Если несколько раз нажимать старт, то будет ускоряться шарик. Защита: 
	if(t!=null) return;
9. Чтобы знать сост-е потока, добавим label. Первое сост-е null (потока нет). 
10. Добавляем пояснение. Когда создали Thread:
	jLablel1.setText("Поток создан");
	Когда включили: 
	jLabel1.setText("Поток работает")
	После while: 
	JLabel1.setText("Поток остановлен")
11. Создаём флаг (глобальная перем-я) boolean run. В while сделаем while(run), а не while(true), чтобы можно было останавливать
12. Для этого создадим кнопку для остановки потока (без возобновления)
	1. Жёсткий способ. t.stop(); t = null; 
	2. Мягкий способ. run = false; t = null; В этом случае мы можем получить сообщение, что поток остановлен. Но поток может дальше жить
	3. Мягкий способ. Вызов InterruptedException: t.interrupt(); а при обработке run = false; Здесь поток останавливается и освобождает ресурсы (сейчас он их не захватывает)
13. Приостановка потока.
	1. boolean pause = false;
	2. Добавление кнопки
	3. Обработчик: pause = true;
	4. В блоке try: if(pause)
			{
			wait(); - небезопасно => обработать InterruptedException
			pause = false;}
	5. Проблема: wait() вызван в несинхронной секции. Помещаем в синхронную:
			synchronized(this){
			wait();
			pause=false;}
	6. Также можно добавить сообщение "Пауза"
14. Пробуждение потока.
	1. Создание кнопки
	2. Либо секция synchronized, либо  synchronized метод contPlay(). В методе notyfyAll();
	3. В обработчике вызвать contPlay()
## Несколько шариков
Нужно делать next более сложным.
![[Pasted image 20230218114726.png]]
Создать moveCircle1 и moveCircle2
Сам проект:
![[Pasted image 20230218115117.png]]
## JavaFX
Project -> JavaFX -> FormFX, ещё что-то
Получили заготовку.
![[Pasted image 20230218115336.png]]
Есть дизайнер и программист. Для разделения существует интерфейс для внешности - файл fxml. Он читается в программе и применяется. Сцена помещается в stage.
Сам fxml часто на xml
![[Pasted image 20230218115520.png]]
Важное выделено.
1. Можно либо его редачить, либо исп-ть scenebuilder. scenebuilder можно поставить отдельно: описать интерфейс:
	1. Панель
	2. Окружность
	3. Кнопка старт
2. Сохранить среди исходников проги как MainFrame.
3. Можно создать класс MainFrame. Там скопировать код, но подключать свой fxml-документ.
4. Создать контроллер (они ни от кого не наследуются)
5. Отрегулировать сцену по ширине и высоте: ![[Pasted image 20230218120105.png]] ![[Pasted image 20230218120125.png]]
6. Заставим двигаться ![[Pasted image 20230218120239.png]]
	1. Указываем id в fxid
	2. У кнопки завести метод типа OnAction runCircle 
	3. Создаём ссылки: @FXML. Имена и методы должны быть те же.
	![[Pasted image 20230218120649.png]]
Добавить сон на 100 миллисекунд и обрамить этот сон try - catch. 
Таким образом, можно использовать основные примитивы.
В начале след пары будет рассказано ещё немного о потоки (пулл потоков), а потом приём лабораторных. Запись лекции и описание лаб будет к понедельнику.
