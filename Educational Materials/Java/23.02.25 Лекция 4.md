# Создание пулла потоков и управление ими
Создан новый проект в NetBeans IDE, потом создана форма с панелью.
public class ballPanel extends javax.swing.JPanel{
ArrayList<Integer> arrX = new ArrayList<>() // содержит коорд по x для каждого шарика
int cnt = 5; - число шариков
int r = 10; радиус шариков
}
public ballPanel(){
	initComponents();
	for(int i=0; i < cnt; i++){
		arrX.add}
}
protected void paintComponent(Graphics g){
	for(int i=0;i<cnt;i++){
	int x= arrX.get(i);
	int y = (i+1)(r\*2+5);
	g.drawOval(x-r,y-4,2\*r,2\*r)}
}
public void next(){
	int x = arrX.get(i);
	x+=10;
	if(x>this.getWidth()){
	x=0;}
	arrX.set(i,x);
	//...
}
Создаём отдельный класс для перемещения шарика. Он будет имплементировать Runnable
public class move{
int ind; // индекс шарика
ballPanel bp; // ссылка на форму
оба пар-тра передаются в конструкторе
public void run(){
	for(int i=0;i<20;i++) {
	try{
		bp.next(ind);
		Thread.sleep(100+ind\*5); // чтобы с разной скоростью
	}
	catch(InterruptedException){
	}	
}
}
Заставим двигаться шарики - кнопка runAll. Можно было создать отдельный класс, в кот поток двигает все шарики, сейчас будем множество потоков юзать.
В ballPanel добавим getCnt(){
	return cnt;
}
private void кнопка{
	for(int i=0;i<ballPanel1.getCnt();i++){
		new Thread(new moveBall(i,ballPanel1)).start();}
}
Плюсы: 
	1. Асинхронная работа нескольких потоков. Для корректности писать аккуратно метод next, так как он вз-ет с общ данными ArrX. Это можно исп-ть, так как мы юзаем разные участки. Иначе не public void next, а syncronized public void next
Минусы:
	1. Постоянно создаются новые потоки для вып-я нек пула задач. Если бы было 100 задач, то пришлось бы создать 100 потоков. Но иногда для эффективности нужно создавать меньше потоков (поддержка потоков, изменение контекста тратят ресы)
	2. Пусть задачи приходят постепенно. Создаются постепенно потоки, потом удаляются. Сборщику мусора нужно разбираться с множеством создаваемых/уничтожаемых объектов.
Вывод: создать нек число потоков, потом они дают задачи для исп-я - создать пулл потоков.
## Executors
В этом пакете есть много разных вещей: 
1. ExecutorService - фабрика
2. потокобезопасная СД
3. семафоры
4. TimeUnit. В ранних версиях Java если хотелось делать задержку, то sleep(milliseconds). Есть TimeUnit, в кот можно ук-ть, в каких единицах делать задержку: TimeUnit.MINUTES.sleep(10); - 10 минут. Для секунд: TimeUnit.MINUTES.sleep(10); - 10 секунд. Это другой способ управления задержками. Также он может конвертировать время.
5. многое другое
ExecutorService servicd = Executors. // порождает неск вар-тов, как создаются потоки:
	1. cashTrhead... - пулл по необходимости (не удаляет, повторно исп-ет)
	2. FixedThread... - фикс пулл
	3. SingleThreadExecutor - один поток, кот дают задачи для исп-я
Создали по необх-ти, кнопку runcashThread
Запуск задач похож на созд-е новых потоков, но это будет через service. У него есть интерфейс Runnable и Callable (если делаем насл от него, то можем получить рез-т выч-я в виде объекта, в Runnable рез-т работы не возвр-ся)
service.submit(new moveBall(...)) - это в цикле.
Создадим новый сервис запуска - SingleThreadExecutor. Создали кнопку runAllst для него.
service.submit(new moveBall(...)) - в цикле. Тогда задачи будут вып-ся друг за другом по очереди, т.е. сначала проедет один круг, потом другой и т.д.
Третий вариант - создать пулл потоков.
ExecutorService servicePool.FixedThread...(2) - 2 потока. Снова кнопка для запуска пулла. Снова сабмитим задачи. Сначала первая пара шариков вып-ся. Как только одна из задач вып-на, то берётся новая из очереди.
При создании сам-но пулла потоков, будут накладные расходы. Поэтому лучше воспользоваться сущ-щей реализацией.
Вопрос: как упр-ть задачами, которые мы засабмитили?
serviceST.submit - когда его делаем, возвр-ся объект класса Future.
Future task = serviceST.submit(new moveBallI(0,ballPanel1)); 
Что можно с ним делать:
	1. Если задачу submit, то можно cancel - отмена задачи. Для задачи InterruptedException - это лучше использовать для отмены. 
	2. get() или get(с таймаутом) - синхронный. Мы пытаемся дождаться заверш-я потока. Если объект основан на Runnable, то ничего, Callable - получим рез-т
	3. Ещё что-то (не успел)
Сам сервис:
	1. shutdown - завершить весь пулл
	2. shutdownNow - то же, чуть другое
	3. isTerminated - узнать, остановлен ли поток
	4. Узнать, все ли потоки удалены (?)
Мы можем наследоваться только или Callable, или от Runnable. Иначе будут два разных метода, отвеч за парал задачу:
public class CE implements Callable<String>, Runnable{
public String call()
public void run()
}
Этот код не скомпилится, так как нельзя будет понять, к какому интерфейсу приводить, а значит, что вызывать.
Интерфейс Callable - шаблонный. Получение рез-та через Future.
## Советы по лабам
Мишени делают шаг и стрела делает шаг. При совпадении стрела исчезает и зачисляется попадание. При нескольких потоках мишени - разделяемый ресурс. Если нужно двигать мишени, то это в крит секции, стрела тоже в синх секции. Потоки захватывают мишени в крит секцию. 
Развитие - стрелков будет несколько, которыми будут управлять пользователи из разных приложений.
Вопросы по лабам можно сдавать на портале. Вопросы "есть exception, из-за чего он возник?" не стоит задавать, даже если есть скриншот.
Задачи нужно сдавать в срок. Те, кто не успел показать в последний момент, получат незачёт. Лучше показывать хоть какие-то последние наработки, чтобы можно было обсудить наработки.
Если есть несколько потоков, нужно синхронизировать
Лучше делать в отдельных классах, чтобы потом легче можно было масштабировать.
Завели массив x, массив y. Делать лучше через классы.
Main.class.getResourses(строка) - получить ресурсы по положению относ класса. Их класть в ту же директорию, где класс.