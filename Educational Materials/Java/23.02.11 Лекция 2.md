# Продолжение общих сведений о Java
## Наследование
public class Main {
public static void main(String[] args){

}
}
Лучше каждый класс в отдельном файле, но можно и в одном.
class A{
int a =10;
public A(int a){
this.a=a;
}
public void print(){
System.out.println("A a="+a);
}
}
A a - ссылка, а не объект.
Наследование:
class B extends A{
int b;
public B(int b, int a){
	super(a);
	this.b=b;

}
@Override public void print(){
	super.print();
	System.out.println("B b=")
}
}
Тогда можно создать 
A p;
p = new B(10,20);
## Интерфейсы
interface Printable{
	void print();
} - интерфейс функциональный (содержит только один метод).
В интерфейсе нет полей.
Реализация интерфейса:
class P implements Printable{
	int val;
	public P(int val){
		this.val = val;
	}
	@Override 
	public void print(){
		System.out.println("P val="+val);
	}
}
Зачем нужны интерфейсы: 
class Proc{
	Printable p; - ссылка на интерфейс
	public Proc(Printable p){
		this.p=p;
	}
	public void run(){
	System.out.println("Start");
	p.print();
	System.out.println("Finish");
	}
}

Proc p1 = new Proc(new P(30)) - мы создаём процесс, внутри которого создан процесс, реализующий интерфейс.
## Анонимный класс
Proc p2 = new Proc (new Printable(){
	@Override
	public void print(){
		...
	}
});
Мы создали класс на основе Printable с перегрузкой метода, но никак не назвали, с объектом этого анонимного класса.
## Уровни доступа
Если в том же пакете, то полный доступ. Для другого пакета private.
## Лямбда-выражения
Если у класса есть только один метод, то можно сделать лямбда-выражение. Иначе пришлось бы порождать анонимный класс.
Proc p3 = new Proc( ()->{
	Реализация лямбда-выражения (перегрузка единственного метода)
}); - быстрее, чем анонимный класс
## Захват по ссылке
В отличие от С, в джаве захват всегда по ссылке.
Proc p3 = new Proc{
	(v2) -> {System.out.println("val="+a1.a+" v2= "+v2\*3)}
}
# Потоки
Содержание:
- класс Thread
- Интерфейс Runnable
- Работа с приоритетами
- Синхронизация
- Методы wait(), notify(), notifyAll() класса Object
- Прерывание потоков
## Класс Thread
- Поток в Java представляется экземпляром класса Thread
- Создание потока (для передачи данных потокам нужно создать поля)
	1. Создание наследника от Thread и переопределение метода run(). Вызов метода start() нового объекта для нового потока
	2. Поток через интерфейс (можно через анонимный класс или лямбда-выражением): ![[Pasted image 20230211130041.png]]
## Управление приоритетами
getPriority() и setPriority() - методы.
Массив: Thread t[] = new Thread[3];
Константы: 
- Thread.MIN_PRIORITY
- Thread.MAX_PRIORITY
## Демон-потоки
Потоки-демоны позволяют описывать:
- фоновые процессы, кот нужны только для обслуживания осн потоков выполнения
- не могут существовать без осн потоков (без потоков-недемонов)
Для работы с этим свойством вызывается до создания потока setDaemon().
Перезапуск потока - создание объекта заново.
![[Pasted image 20230211131231.png]]
static поле принадлежит классу, а не объекту
final - нельзя переопределить (если объект, то = const в Си)
Исключения через try - catch. Если не обрабатывать некоторые исключения, то не скомпилируется.
![[Pasted image 20230211131819.png]]
Когда все потоки завершаются, он автоматически завершится.
Потоки могут использоваться для логирования того, какая часть выполнена.
## Синхронизация
Бывает, что неск одновр читают и пишут. Чтобы от этого избавиться, выполняют синхронизацию.
Перем. можно объявить как volatile (они не кэшируются) - ухудшает произд-ть
Более общий вар-т - создание критич секций. Исп-ть ключевое слово synchronized. Оно распространяется на блок кода или ещё что-то
Thread.yield() - передача управления потоком.
Example:
	public void run(){
	synchronized(data){
		shared.process();
		}
	}
Это позволяет синхронизировать разные группы потоков, а не все, что ускоряет вычисления.
### Synchronized-методы
deadlock - взаимоблокировка. Решение: нумерация ресурсов и захват всегда в строгом порядке.
## Методы wait(), notify(), notifyAll() класса Object
Любой поток может вызвать wait() любого объекта и таким образом попасть в его wait-set. Выполнение потока приостан-ся пока другой не вызовет у этого объекта метод notifyAll(). notifyAll() пробуждает все потоки из  wait-set. notify() пробуждает случайный поток (конкретный нельзя).
![[Pasted image 20230211133406.png]]
![[Pasted image 20230211133449.png]]
wait() - небезопасный -> ловить исключения.
Для чего: есть анимация, делаем wait - остановка, затем notify - снова запуск.
Решение notify случайного - создать число объектов по числу потоков и у конкретного объекта вызывать notify.
## Прерывание потока
- join - ожидание завершения потока.
- stop - мгновенная остановка потока. Никакие сокеты и файлы не закрываются.
Можно ввести переменную, по которой понятно, что поток можно завершать. Но в wait или sleep это не получится. Решение: выдать исключение методом interrupt. При ловле его можно будет выйти.
## Полезные методы
![[Pasted image 20230211134305.png]]
